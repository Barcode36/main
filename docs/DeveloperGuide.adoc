= Expense Tracker- Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title: Table of Contents
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
:experimental:
ifdef::env-github[]
:tips-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/CS2103-AY1819S1-T12-1/main

By: `Team T12-1`      Since: `Oct 2018`      Licence: `MIT`

== Introduction

The Expense Tracker application is a desktop application which enables users to track their expenses.
The application features both a Command Line Interface (CLI) and a Graphical User Interface (GUI) which provides users
with the efficiency of the CLI while still having the benefits of a GUI. +

This application was morphed from https://github.com/se-edu/addressbook-level4[AddressBook-Level4], developed by https://github.com/se-edu/[se-edu]


== Setting up

'''
Follow the guide in this section below to start development on ExpenseTracker

'''

=== Prerequisites

. *https://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase9-3934878.html[JDK `9`]* or later

+
[WARNING]
JDK `10` on Windows will fail to run tests in <<UsingGradle#Running-Tests, headless mode>> due to a https://github.com/javafxports/openjdk-jfx/issues/66[JavaFX bug].
Windows developers are highly recommended to use JDK `9`.

. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.


=== Setting up the project in your computer
*To set up the project:*

. Fork this repo and clone the fork to your computer
. Open IntelliJ (if you are not in the https://i.stack.imgur.com/cQnLl.png[welcome screen], click `File` > `Close
Project` to close
 the
existing project dialog first)

. Click `Configure` > `Project Defaults` > `Project Structure`
. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

=== Verifying the setup
*To verify that you have successfully set the project up:*

. Run the `seedu.address.MainApp` and try a few commands
. <<Testing,Run the tests>> and ensure that they all pass.

=== Configurations to apply before writing code

The following lists configurations that should be applied before writing code:

==== Configuring the coding style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.adoc[oss-generic coding
standards]. IntelliJ's default style is mostly compliant but it uses a different import order from ours. To rectify:

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS)
. Select `Editor` > `Code Style` > `Java`
. Click on the `Imports` tab to set the order

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent IntelliJ from contracting the import statements
* For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Updating documentation to match your fork

If you plan to develop this fork as a separate product (instead of contributing to expense tracker), you should do the following:

. Configure the <<Docs-SiteWideDocSettings, site-wide documentation settings>> in link:{repoURL}/build.gradle[`build.gradle`], such as the `site-name`, to suit your own project.

. Replace the URL in the attribute `repoURL` in link:{repoURL}/docs/DeveloperGuide.adoc[`DeveloperGuide.adoc`] and link:{repoURL}/docs/UserGuide.adoc[`UserGuide.adoc`] with the URL of your fork.

==== Setting up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

After setting up Travis, you can optionally set up coverage reporting for your team's fork (see <<UsingCoveralls#,
UsingCoveralls.adoc>>).

[NOTE]
Coverage reporting could be useful for a team repository that hosts the final version but it is not that useful for your personal fork.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based)

=== Before coding

Before you start coding, get a sense of the overall design by reading <<Design-Architecture>>.

== Design

[[Design-Architecture]]
=== Architecture

[discrete]
==== Overview of Architecture

.Architecture Diagram
image::Architecture.png[width="600"]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.pptx` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder. To update a diagram, modify the diagram in the pptx file, select the objects of the diagram, and choose `Save as picture`.

`Main` has only one class called link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components. Two of those classes play important roles at the architecture level.

* `EventsCenter` : This class (written using https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library]) is used by components to communicate with other components using events (i.e. a form of _Event Driven_ design)
* `LogsCenter` : Used by many classes to write log messages to the App's log file.

`Logic` is the command executor. It defines its API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.
Read <<Design-Logic,*`Logic`*>> for more details. Its class diagram is given below:

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[width="800"]

`UI` is responsible for the UI of the App. It defines its API in the `Ui.java` interface and exposes its functionality using the `UiManager.java` class.
Read <<Design-Ui,*`UI`*>> for more details.

`Model` holds the data of the App in-memory. It defines its API in the `Model.java` interface and exposes its functionality using the `ModelManager.java` class.
Read <<Design-Model,*`Model`*>> for more details.

`Storage` reads data from, and writes data to, the hard disk.It defines its API in the `Storage.java` interface and exposes its functionality using the `StorageManager.java` class.
Read <<Design-Storage,*`Storage`*>> for more details.

[discrete]
==== Events-Driven nature of the design

The Expense Tracker's architecture style is events-driven style. Here is an illustration of how this architecture works.
The _Sequence Diagram_ below shows how the components interact for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command (part 1)
image::SDforDeletePerson.png[width="800"]

[NOTE]
Note how the `Model` simply raises a `ExpenseTrackerChangedEvent` when the Expense Tracker data are changed, instead of asking the `Storage` to save the updates to the hard disk.

The diagram below shows how the `EventsCenter` reacts to that event, which eventually results in the updates being saved to the hard disk and the status bar of the UI being updated to reflect the 'Last Updated' time.

.Component interactions for `delete 1` command (part 2)
image::SDforDeletePersonEventHandling.png[width="800"]

[NOTE]
Note how the event is propagated through the `EventsCenter` to the `Storage` and `UI` without `Model` having to be coupled to either of them. This is an example of how this Event Driven approach helps us reduce direct coupling between components.

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[width="800"]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `ExpenseListPanel`, `StatusBarFooter`, `BrowserPanel` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Binds itself to some data in the `Model` so that the UI can auto-update when data in the `Model` change.
* Responds to events raised from various parts of the App and updates the UI accordingly.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[width="800"]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

*  `Logic` uses the `ExpenseTrackerParser` class to parse user commands.
*  This results in a `Command` object which is executed by the `LogicManager`.
*  The command execution can affect the `Model` (e.g. adding a expense) and/or raise events.
*  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeletePersonSdForLogic.png[width="800"]

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::UpdatedModelComponentClassDiagram.png[width="800"]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `ModelManager` which implements the interface `Model` (Figure 8):

* stores a `UserPref` object that represents the user's preferences.
* stores the a list of expenses.
* exposes an unmodifiable `ObservableList<Expense>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[NOTE]
To better adhere to the paradigms of OOP, we can store a `Tag` list in `Expense Tracker`, which `Expense` can
reference. This
would allow `Expense
Tracker` to only require one `Tag` object per unique `Tag`, instead of each `Expense` needing their own `Tag` object. An example of how such a model may look like is given below. +
 +
image:BetterOopModelComponentClassDiagram.png[width="800"]

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[width="800"]

The *_Structure of the Storage Component_* given above shows the relationships between classes in the storage component.

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Expense Tracker data in xml format and read it back.
* can read multiple xml format files with separate Expense Tracker data from a folder.
* XmlAdaptedPassword is stored as a SHA-256 hash of the original password.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::undoredo[]
//=== Undo/Redo feature
//==== Current Implementation
//
//The undo/redo mechanism is facilitated by `VersionedExpenseTracker`.
//It extends `ExpenseTracker` with an undo/redo history, stored internally as an `expenseTrackerStateList` and `currentStatePointer`.
//Additionally, it implements the following operations:
//
//* `VersionedExpenseTracker#commit()` -- Saves the current expense tracker state in its history.
//* `VersionedExpenseTracker#undo()` -- Restores the previous expense tracker state from its history.
//* `VersionedExpenseTracker#redo()` -- Restores a previously undone expense tracker state from its history.
//
//These operations are exposed in the `Model` interface as `Model#commitExpenseTracker()`, `Model#undoExpenseTracker()` and `Model#redoExpenseTracker()` respectively.
//
//Given below is an example usage scenario and how the undo/redo mechanism behaves at each step.
//
//Step 1. The user launches the application for the first time. The `VersionedExpenseTracker` will be initialized with the initial expense tracker state, and the `currentStatePointer` pointing to that single expense tracker state.
//
//image::UndoRedoStartingStateListDiagram.png[width="800"]
//
//Step 2. The user executes `delete 5` command to delete the 5th expense in the expense tracker. The `delete` command calls `Model#commitExpenseTracker()`, causing the modified state of the expense tracker after the `delete 5` command executes to be saved in the `expenseTrackerStateList`, and the `currentStatePointer` is shifted to the newly inserted expense tracker state.
//
//image::UndoRedoNewCommand1StateListDiagram.png[width="800"]
//
//Step 3. The user executes `add n/David ...` to add a new expense. The `add` command also calls `Model#commitExpenseTracker()`, causing another modified expense tracker state to be saved into the `expenseTrackerStateList`.
//
//image::UndoRedoNewCommand2StateListDiagram.png[width="800"]
//
//[NOTE]
//If a command fails its execution, it will not call `Model#commitExpenseTracker()`, so the expense tracker state will not be saved into the `expenseTrackerStateList`.
//
//Step 4. The user now decides that adding the expense was a mistake, and decides to undo that action by executing the `undo` command. The `undo` command will call `Model#undoExpenseTracker()`, which will shift the `currentStatePointer` once to the left, pointing it to the previous expense tracker state, and restores the expense tracker to that state.
//
//image::UndoRedoExecuteUndoStateListDiagram.png[width="800"]
//
//[NOTE]
//If the `currentStatePointer` is at index 0, pointing to the initial expense tracker state, then there are no previous expense tracker states to restore. The `undo` command uses `Model#canUndoExpenseTracker()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the undo.
//
//The following sequence diagram shows how the undo operation works:
//
//image::UndoRedoSequenceDiagram.png[width="800"]
//
//The `redo` command does the opposite -- it calls `Model#redoExpenseTracker()`, which shifts the `currentStatePointer` once to the right, pointing to the previously undone state, and restores the expense tracker to that state.
//
//[NOTE]
//If the `currentStatePointer` is at index `expenseTrackerStateList.size() - 1`, pointing to the latest expense tracker state, then there are no undone expense tracker states to restore. The `redo` command uses `Model#canRedoExpenseTracker()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the redo.
//
//Step 5. The user then decides to execute the command `list`. Commands that do not modify the expense tracker, such as `list`, will usually not call `Model#commitExpenseTracker()`, `Model#undoExpenseTracker()` or `Model#redoExpenseTracker()`. Thus, the `expenseTrackerStateList` remains unchanged.
//
//image::UndoRedoNewCommand3StateListDiagram.png[width="800"]
//
//Step 6. The user executes `clear`, which calls `Model#commitExpenseTracker()`. Since the `currentStatePointer` is not pointing at the end of the `expenseTrackerStateList`, all expense tracker states after the `currentStatePointer` will be purged. We designed it this way because it no longer makes sense to redo the `add n/David ...` command. This is the behavior that most modern desktop applications follow.
//
//image::UndoRedoNewCommand4StateListDiagram.png[width="800"]
//
//The following activity diagram summarizes what happens when a user executes a new command:
//
//image::UndoRedoActivityDiagram.png[width="650"]
//
//==== Design Considerations
//
//===== Aspect: How undo & redo executes
//
//* **Alternative 1 (current choice):** Saves the entire expense tracker.
//** Pros: Easy to implement.
//** Cons: May have performance issues in terms of memory usage.
//* **Alternative 2:** Individual command knows how to undo/redo by itself.
//** Pros: Will use less memory (e.g. for `delete`, just save the expense being deleted).
//** Cons: We must ensure that the implementation of each individual command are correct.
//
//===== Aspect: Data structure to support the undo/redo commands
//
//* **Alternative 1 (current choice):** Use a list to store the history of expense tracker states.
//** Pros: Easy for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project.
//** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `VersionedExpenseTracker`.
//* **Alternative 2:** Use `HistoryManager` for undo/redo
//** Pros: We do not need to maintain a separate list, and just reuse what is already in the codebase.
//** Cons: Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things.
//// end::undoredo[]

//tag::useraccounts[]

=== User Accounts System
The user accounts system allows multiple users to use the Expense Tracker on the same computer without interfering with each other's data. It also includes an optional password system that allows users to protect their expense tracker information from being viewed or altered by others.

==== Current Implementation
On initialization, the `MainApp` class loads all xml files within the data folder according to the path in `UserPrefs`. The data is loaded by `MainApp#initModelManager(Storage, UserPref)`.
[NOTE]
====
An xml data file not be loaded if the username value is not the same as the filename (ignoring file extension).
====

This system is facilitated by newly added methods in the Model interface which now supports the following operations:

* `Model#loadUserData(Username, Password)` -- Logs in to the user with the input Username and Password and loads the associated data into the `Model`. Returns true if the password matches the user's password, else the user is not logged into and false is returned
* `Model#unloadUserData()` -- Unselects the user in the `Model`
* `Model#isUserExists(Username)` -- Checks if a user with the input Username exists in the `Model`
* `Model#addUser(Username)` -- Adds a new user with the given Username to the `Model`
* `Model#hasSelectedUser()` -- Checks if a user is currently logged in in the `Model`

The classes `Username` and `Password` have also been implemented and have the following noteworthy characteristics:

* Two `Username` classes are equivalent if and only if the internal username String are equivalent (case-insensitive).
* `Username` cannot be constructed with a String containing any of the following characters: _" > < : \ / | ? *_
* When a `Password` class is constructed with plain text, the password is hashed before being stored as an internal String in the `Password` object
* `Password` is only valid if the plain text form is at least 6 characters long

Below is an example usage scenario and how the User Account System behaves at each step when the application is launched.

. The user launches the application and the directory path in the UserPref points at the _data_ folder
. The method `StorageManager#readAllExpenses(Path)` is called by the MainApp and the method loads all the xml data files in the _data_ folder and returns the loaded data as a `Map<Username, EncryptedExpensetracker>` with the `Username` of the user data as the key and the user data as an `EncryptedExpenseTracker` as the value to the MainApp class.
. A `Model` instance will then be initialized using the previously mentioned `Map` of user data.

Below is the UML sequence diagram of the `StorageManager#readAllExpenses(Path)` method mentioned.

.Sequence diagram of the `StorageManager#readAllExpenses(Path)` method
image::implementation/ReadAllExpensesSequenceDiagram.png[width="800"]

Below is an example usage scenario and how the Sign Up and Login system behaves at each step after the application is launched.

. The user executes the command `signup john` to create a user with the `Username` john
. The `signup` command calls `Model#addUser(Username)` which adds the user `john` to the `Model`. The operation is successful as `john` does not break any of the `Username` constraints and does not already exist in the Model.
. The user then executes the command `login u/john` to log in to his user account
. The `login` command calls `loadUserData(Username, Password)` with a null password as a password was not provided. The method is executed successfully as the user `john` has no password set.
. The selected data in the `Model` is switched to `john`'s and an `UserLoggedInEvent` is raised for the `UI` to show `john`'s Expense Tracker data

Below is the UML sequence diagram that shows how the `SignUpCommand` works.

.Sequence diagram showing how `SignUpCommand` works
image::implementation/SignUpCommandSequenceDiagram.png[width="800"]

Below is the UML sequence diagram that shows how the `LoginCommand` works.

.Sequence diagram showing how `LoginCommand` works
image::implementation/LoginCommandSequenceDiagram.png[width="800"]

Below is an example usage scenario and how the Password system behaves at each step after the he/she is logged in.

. The user is already logged in to the account `john` with an existing password `password1` and executes the command `setpassword o/password1 n/password2` to change his password to `password2`
. The `setpassword` command calls the `Model#setPassword(Password)` method since the given old password matches his existing password and `password2` does not violate any password constraints
. The `Model#setPassword(Password)` changes `john`'s account password to `password2`

Below is the UML sequence diagram that shows how the `SetPasswordCommand` works.

.Sequence diagram showing how `SetPasswordCommand` works
image::implementation/SetPasswordCommandSequenceDiagram.png[width="800"]

==== Design Considerations
===== Aspect: Storage of Separate User Data

* **Alternative 1 (current choice):** Save each user's data into a seperate xml file
** Pros: More work needed to implement as the data loading has to be changed to read from multiple xml files
** Cons: Users can transfer their own data between computers easily by just copying their own account's xml file
* **Alternative 2:** Save all the separated user data in a single xml data file
** Pros: Relatively easier to implement. ExpenseTracker already loads data from a single xml data file so less work has to be done to change the storage structure
** Cons: Users will be unable to easily transfer their individual data to another computer

===== Aspect: Loading of User Data

* **Alternative 1 (current choice):** Loading of User data is only done on initialization of the Expense Tracker
** Pros: Ability to switch user accounts quickly after the Expense Tracker is loaded as all users are already loaded into memory
** Cons: External changes to the data files after initialization will not be reflected may be overwritten
* **Alternative 2:** User data is loaded only when the user attempts to log in
** Pros: Unnecessary data is not kept in memory so memory space is not wasted
** Cons: Increase degree of coupling between the Logic, Model and Storage components as the login command will require the Storage to load and return the user's data.
// end::useraccounts[]

// tag::statistics[]
=== Statistics

The implementation of the Statistics function can be divided into two parts - preparation and execution.
Given below is an example usage scenario and an explanation of how the statistics mechanism behaves at each step.

==== Preparation
In the preparation phase, the program parses the command for statistics, prepares filters used by the model
and posts events in `EventsCenter`.
Below is the UML sequence diagram and a step-by-step explanation of the preparation stage.

.Sequence diagram of the preparation stage in the statistics mechanism
image::implementation/StatsCommandSequenceDiagram.png[width="800"]

. User enters command `stats n/7 p/d m/t`. The command is received by `ExpenseTrackerParser`, which calls `StatsCommandParser#parse()`
to create a `StatsCommand` object with the two extracted parameters. The `StatsCommand` object is returned to `LogicManager`.

. `LogicManager` then calls `StatsCommand#execute()`, which updates the `Predicate` and `StatsMode` in `ModelManager and
also posts a `ShowStatsRequestEvent` and `SwapLeftPanelEvent` event to the `EventsCenter`.

In this example, `Predicate` is set to filter out expenses which have dates within the last 7 days and
`StatsPeriod` is set to TIME, which will be used later to have the UI display a bar chart instead of a pie chart.

==== Execution
In the execution phase, the program handles the events posted by `StatsCommand` by
processing and retrieving the data to be displayed and finally displaying it.
Below is the UML sequence diagram and a step-by-step explanation of the execution stage.

.Sequence diagram of the execution stage in the statistics mechanism
image::implementation/StatsUiSequenceDiagram.png[width="800"]

. The `ShowStatsRequestEvent` event is handled by `MainWindow#handleShowStatsEvent()`, which calls 'StatisticsPanel#setData()'
and passes the data as parameters by calling
`Logic#getExpenseStats()`, `Logic#getStatsPeriod()`, `Logic#getStatsMode()` and `Logic#getPeriodAmount()`.

. `Logic#getExpenseStats()` gets the filtered expense list by calling `Model#getExpenseStats()`, which returns
an unmodifiable `ObservableList`, only containing only expenses in the last 7 days, as per the `Predicate`, and sorted by date.
`Logic#getExpenseStats()` then organises the data into a `LinkedHashMap<String, Double>`, where the key value pair represents
the x and y values of the chart. In this case, `StatsMode` is set to TIME, which results in a x,y values of date and cost.
If `StatsMode` is set to CATEGORY, the x,y values will be set to category and cost.

. `Logic#getStatsPeriod()`, `Logic#getStatsMode()` and `Logic#getPeriodAmount()` gets their respective data
 by calling the method of the same name in `Model`.

. Once the parameters are passed into `StatisticsPanel#setData()`, `StackPane#getChildren()#clear()` is called to clear
any display elements in `StackPane`.

. In this case, `StatsMode` is set to TIME, which results in `StatisticsPanel#setTimeBasedData()` to be called, which
generates a Bar Chart and calls `StackPane#getChildren()#add()`, which adds it to `StackPane`.
If `StatsMode` is set to CATEGORY, which results in `StatisticsPanel#setCategoryBasedData()` to be called, which
generates a Pie Chart and calls `StackPane#getChildren()#add()`, which adds it to `StackPane`.
If the data received is empty, a `Text` object is generated and `StackPane#getChildren()#add()` is called,
which informs the user that there are no expenditures

==== Design Considerations

===== Aspect: How to handle statistic data and parameters

* **Alternative 1 (current choice):** Data and each parameter is handled as separate objects
** Pros: Easy to implement.
** Cons: Need to call multiple methods to get parameters
* **Alternative 2:** Create Statistics object which contains data and all the parameters.
** Pros: More scalable. Less method calls to get parameters.
** Cons: None

===== Aspect: How to pass statistic data and parameters from Command to UI

* **Alternative 1 (current choice):** UI gets all data and parameters from `Logic`, which gets data from `Model`.
** Pros: Easy to implement. Aligned with architecture.
** Cons: A lot of method calls
* **Alternative 2:** Pass data and parameters through event
** Pros: Less method calls. Easier to read.
** Cons: Not in aligned with architecture. Need to consider application startup when there are no events posted.
// end::statistics[]

// tag::find[]
=== Find

Below is the UML sequence diagram and a step-by-step explanation of an example usage scenario.

.Sequence diagram of find mechanism
image::implementation/FindCommandSequenceDiagram.png[width="800"]

. User enters command `find n/Have Lunch f/Food d/01-01-2018:03-01-2018`. The command is received by `ExpenseTrackerParser`,
which then creates a `FindCommandParser` Object and calls `FindCommandParser#parse()` method.

. `FindCommandParser#parse()` method calls `ArgumentTokenizer#tokenize()` to tokenize the input String into keywords and store them in
an `ArgumentMultimap` Object.

. `FindCommandParser#parse()` method then calls `ParserUtil#ensureKeywordsAreValid()` method. If any
of the keywords doesn't conform to the correct format, `ParseException` will be thrown. If no exception is thrown, a
`ExpenseContainsKeywordsPredicate` Object is created. It implements Predicate<Expense> interface and is used to filter
out all the expenses which matches the keywords entered by the user.

. A `FindCommand` Object with the `ExpenseContainsKeywordsPredicate` Object as parameter is created and returned to
`LogicManager`.

. `LogicManager` then calls `FindCommand#execute()`,which calls `Model#updateFilteredExpenseList()`
method to update the predicate of FilterList<Expense>. FilterList now contains new set of expenses which filtered by the
new predicate.

. Then the expense list panel will show a new set of expenses according to the keywords. A `CommandResult` is then created
and returned to `LogicManager`.

// end::find[]

// tag::massedit[]
=== Mass Edit

Below is the UML sequence diagram and a step-by-step explanation of an example usage scenario.

.Sequence diagram of mass edit mechanism
image::implementation/MassEditCommandSequenceDiagram.png[width="800"]

. User enters command `massedit c/school -> c/work d/01-01-2018`. The command is received by `ExpenseTrackerParser`,
  which then creates a `MassEditCommandParser` Object and calls `MassEditCommandParser#parse()` method.

. `MassEditCommandParser#parse()` method calls `ArgumentTokenizer#tokenize()` to tokenize the input String into keywords and store them in
two `ArgumentMultimap` Objects.

. `MassEditCommandParser#parse()` method then create a `ExpenseContainsKeywordsPredicate` Object. Then it calls `EditExpenseDescriptor#createEditExpenseDescriptor()` method to create an
`EditExpenseDescriptor` Object which stores the fields of expenses which are going to be edited.

. A `MassEditCommand` Object with the `ExpenseContainsKeywordsPredicate` and `EditExpenseDescriptor` Object as parameters is created and returned to
`LogicManager`.

. `LogicManager` then calls `MassEditCommand#execute()`,which calls `Model#updateFilteredExpenseList()`
method to update the predicate of FilterList<Expense>. `Model#getFilteredExpenseList()` is called to return the FilterList<Expense>.

. A loop starts and for each `Expense` in the FilterList<Expense>, `EditExpenseDescriptor#createEditedExpense()` is called to create an edited Expense object.
Then `Model#updateExpense` is called to replace the original `Expense` with edited `Expense`.

. When loop ends, `Model#updateFilteredExpenseList()` is called again to show the edit `Expense` to the user.
A `CommandResult` is then created and returned to `LogicManager`.

// end::massedit[]

// tag::userinterfaceredesign[]

=== User Interface Redesign

The UI has been redesigned to implement the following UI elements required for the Expense Tracker:

* Budget Panel
* Statistics Panel
* Notifications Panel
* Categories Panel

Animations has been incorporated into the UI elements for a better user experience.

==== Budget Panel

The `totalBudget` panel consists of 4 UI elements:

*	`BudgetPanel#expenseDisplay` – A `Text` element that displays the user’s current expenses.
*	`BudgetPanel#budgetDisplay` – A `Text` element that displays the user’s monthly budget cap.
*   `BudgetPanel#percentageDisplay` - A `TextFlow` objects that manages `BudgetPanel#budgetDisplay` and `BudgetPanel#expenseDisplay`.
*	`BudgetPanel#budgetBar` – A `progressBar` element that visually presents the percentage of the current
`totalBudget` cap that has been used.

Given below is an example scenario of how `BudgetPanel` is updated:

. The user launches the application and signs up for a new account. The `MainWindow` creates a new `BudgetPanel`, which elements are initialized as follows:
* `BudgetPanel#expenseDisplay` is green and set to "$0.00".
* `BudgetPanel#budgetDisplay` is set to "/ $28.00", with $28.00 being the default `totalBudget`.
* `BudgetPanel#budgetBar` is green and at 0% progress.

. The user executes the command `add n/Lunch $/30.00 c/Food`. As the `'add` command modifies the `totalBudget` and
expenses, `AddCommand#execute()` will post a `UpdateBudgetPanelEvent` event to the EventsCenter.
[NOTE]
If a command fails its execution, the `UpdateBudgetPanelEvent` will not be posted.

. The `UpdateBudgetPanelEvent` event is handled by `BudgetPanel#handleBudgetPanelEvent()`, which calls `BudgetPanel#update()`.

. `BudgetPanel#update()` calls `BudgetPanel#animateBudgetPanel()`, which creates a new `Timeline` object.

. Two `KeyFrame` objects are added to the Timeline that smooths the transition of the `BudgetPanel#budgetBar` progress percentage from 0% to the updated percentage.
[NOTE]
If the updated percentage is more than 1.0, `BudgetPanel#budgetBar` progress percentage will be set to 1.0. Barring oversights, the progress percentage should never fall below 0.0.

. A call to 'BudgetPanel#addTextAnimationKeyFrames()` is made to create the incrementing animation for `BudgetPanel#expenseDisplay`. The total time for this animation is 0.5 seconds, and consists of 10 `KeyFrame` objects.
With this information, the amount to increment `BudgetPanel#expenseDisplay` by in each `KeyFrame` can be calculated.
 `BudgetPanel#updateExpenseDisplay()` is called to increment the `BudgetPanel#expenseDisplay`.
[NOTE]
`BudgetPanel#addTextAnimationKeyFrames()` handles the incrementing animation for both the `BudgetPanel#budgetDisplay` and `BudgetPanel#expenseDisplay` at the same time.

. For each `KeyFrame`, 'BudgetPanel#addTextAnimationKeyFrames()` also makes a call to `BudgetPanel#alterTextSize()`. This method checks the height of `BudgetPanel#percentageDisplay`. If said height is
different from `BudgetPanel#percentageDisplay#maxHeight`, `BudgetPanel#percentageDisplay` will be scaled accordingly such that its new width matches `BudgetPanel#percentageDisplay#maxHeight`.

. `Timeline#playFromStart()` is called to execute the animation.

. `BudgetPanel#update()` also calls `BudgetPanel#setBudgetUiColors()`. The method detects that the user has gone
over budget, and changes the color of `BudgetPanel#expenseDisplay` and `BudgetPanel#budgetBar` from green to red.
[NOTE]
Similarly, if the user has gone from over budget to under budget, the color of
'BudgetPanel#expenseDisplay` and `BudgetPanel#budgetBar` should change from red to green.

The following sequence diagram shows the process of updating the `BudgetPanel` UI elements:

.Sequence diagram of the `BudgetPanel` update
image::implementation/BudgetPanelSequenceDiagram.png[width="800"]

==== Design Considerations
===== Aspect: Choosing which library to use for animation implementation

* **Alternative 1 (current choice):** Use the `Timeline` and `KeyFrame` class
** Pros: More flexible; Able to create the animation frame by frame.
** Cons: Animations tricks and effects will require manual tweaking for the intended effect.
* **Alternative 2:** Use the `Transition` class
** Pros: The class is specialized, and thus has built-in methods to create better animations For example, `EASE-BOTH` can be used to cause the transition to accelerate at different points for a better effect)
** Cons: Does not work for certain desired effects, such as the 'incrementing' effect required for the `Text` elements of the `BudgetPanel`.

===== Aspect: Implementation of `Text` elements
* **Alternative 1 (Initial Choice):** Use two `Label` objects; one to display `currentExpenses` and another to display `budgetCap`.
** Pros: Allows the implementation of separate text color changing and animation.
** Cons: Difficult to keep both text objects centralized in relation to the `budgetBar`, especially if `currentExpenses` or `budgetCap` are large numbers.

* **Alternative 2:** Use one `Text` object to display both `currentExpenses` and `budgetCap`
** Pros: Easy to centralize the `Text` object with `budgetbar`.
** Cons: Implementation of animation was messy and tedious. `JavaFX` also does not support multiple colors for a single `Text` object.

* **Alternative 3 (Current Choice):** Wrap two `Text` objects in a `TextFlow` object
** Pros: Easy to centralize the `Text` objects by taking advantage of the properties of `TextFlow`. Allows the implementation of separate text color changing and animation.
** Cons: Does not solve the issue of decentralization when `currentExpenses` or `budgetCap` are large numbers.

===== Aspect: Solving the issue of `TextFlow` positioning when `currentExpenses` or `budgetCap` are large numbers.
* **Alternative 1:** During the budget update, manipulate the font size of both `Text` objects when the `TextFlow` object reaches a certain height.
** Pros: -
** Cons: Difficult to adjust the fonts of both `Text` objects such that the final font size is neither too large nor too short.

* **Alternative 2: ** Manipulate the scale of the `TextFlow` object such that it always maintains a predetermined width.
** Pros: A solution that is simple and easy to implement.
** Cons: In the case of very large numbers, the `TextFlow` object is shrunk down to a point where the text in non-legible. However,
we assume that the average user who is seriously using `ExpenseTracker` will not set  `currentExpenses` or `budgetCap` to such large numbers.

=== Notification System
The Notification System is comprised of the following classes:

* `Notification` - An abstract class that consists of a `header`, `type` and `body`. There are two types of `Notification`,
`TipNotification` and `WarningNotification`.
* `NotificationPanel` `and NotificationCard` - UI elements that displays the list the notifications that have been sent to the user.
* `NotificationHandler` - Manages the list of notifications.
* `NotificationCommand` - Allows the user to toggle what type of notifications they wish to receive.
* `NotificationHandler` - Handles the storage and creation of `Notification` objects.
* `XmlAdaptedNotificationHandler`, `JsonTipsStorage` and `XmlAdaptedNotificationHandler` -  Manages the saving and reading on Notifications.

Given below is an example scenario of how the Notification System functions:

. The user launches the application for the first time. A new `NotificationHandler` is instantiated.

. A call to `NotificationHandler#isTimeToSendTip()` is made upon login. In turn, a check is made to see if it has
been a day since the last `TipNotification` has been sent. If so, a new `TipNotification` is added to the `NotificationHandler#internalList` via a call to `NotificationPanel#addNotification()`.
[NOTE]
If this is the user's first time logging into their account, a new `TipNotification` will be sent.

. The user executes the command `add n/Lunch $/30.00 c/Food`. The `add` command calls `NotificationHandler#isTimeToSendWarning()` to check if the user is nearing or over their budget.
If the user is nearing or approaching their budget, a `WarningNotification` is added to `NotificationHandler#internalList` via a call to `NotificationPanel#addNotification()`.
[NOTE]
The same procedure is carried out if the user executes an `edit` command.

. If the size of `NotificationHandler#internalList` reaches 11 or more, the oldest `Notification` in the list is then replaced with
the new `Notification`.

Given below is an example scenario of how the `NotificationCommand` functions:
. The user executes `notification n/warning t/off`. The command is received by the `ExpenseTrackerParser`.

. A call to `NotificationCommand#parse()` is made, which creates a `NotificationCommandDescriptor` object with the two
extracted parameters `warning` and `off`. A `NotificationCommand` is returned to the `LogicManager`.
[NOTE]
The `n/` suffix and parameter can be omitted. In this case, all types of notifications will be affected by the toggle.

. `LogicManager` then calls `NotificationCommand#execute`, which calls `NotificationHandler#toggleWarningNotifications` to set
`NotificationPanel#isWarningEnabled` to `false`.
[NOTE]
 If `notification n/tip t/on` was executed, `NotificationHandler#toggleTipNotifications()` would be called to set `NotificationHandler#isTipEnabled`
 to `true`.
 If`notification t/on` was executed, `NotificationHandler#toggleBothNotifications()` will be called instead.

==== Design Considerations
===== Aspect: How to Store Notifications



// end::userinterfaceredesign[]

// tag::budget[]

=== Budget
==== Current Implementation
The budget feature allows the user to set a budget for their expenses.
If the user's total expenses exceeds their budget, a warning will be shown to the user.

The current implementation for budget tracking is described as below.

===== Setting a Budget

Given below is a sequence diagram and step by step explanation of how the expense tracker executes when a user sets a budget

.Sequence diagram of a user setting a budget.
image::implementation/BudgetCommandSequenceDiagram.png[width="800"]

. User enters command `setBudget 2.00`.
. The command is received by `ExpenseTrackerParser`, which then creates a `SetBudgetCommandParser` Object and calls
`SetBudgetCommandParser#parse()` method.
. `SetBudgetCommandParser#parse()` will then return a `budget` of `double` type. It will then create a
`SetBudgetCommand` Object with `budget` as a parameter would be created and returned to `LogicManager`.
. `LogicManager` then calls `SetBudgetCommand#execute()`, which calls `ModelManager#modifyMaximumBudget` to update the
 maximum budget of the expense tracker.
. `LogicManager` will then call `EventsCenter#post()` to update the UI, displaying the updated budget.
. The budget is then updated.


===== Setting a recurring Budget

Every time a user logs in, `Model#loadUserData()` is called and  the application will check if the user has set a time
where the
current expenses will reset (recurrence time). If it is not set, the expense tracker will issue a notification. Else, the
expense tracker will track the set recurrence time against the time now. If it exceeds, current expenses will be reset. Else,
nothing will be done.

* Recurrence time is set by `setRecurrenceFrequency()`. If it has not been set before, the next recurrence time will
be set to `currentTime` + `recurrenceFrequency`.
* If it has already been set, the timing will be updated on the next occurrence time

Given below is a sequence diagram and step by step explanation of how the expense tracker executes when a user sets a recurrence frequency.

.Sequence diagram of a user setting a recurrence frequency.
image::implementation/SetRecurringBudgetCommandSequenceDiagram.png[width="800"]

. User enters command `setRecurrenceFrequency min/1`. The command is received by `ExpenseTrackerParser`

. `ExpenseTrackerParser` will then create a `SetRecurringBudgetCommandParser` Object and calls `SetRecurringBudgetCommandParser#parse()` method.

. `SetRecurringBudgetCommandParser#parse()` method calls `ArgumentTokenizer#tokenize()` to tokenize the input String into keywords and store them in
an `ArgumentMultimap` Object.

. `SetRecurringBudgetCommandParser#parse()` method then calls `SetRecurringBudgetCommandParser#areAnyPrefixesPresent()`
method. If none of the keywords are present, `ParseException` will be thrown.

. From the previous step, if no exception is thrown, `ParseUtil#parseHours()`, `ParseUtil#parseMinutes()` and
`ParseUtil#parseSeconds()` will be called to convert the number of hours in seconds, `hours`, the number of minutes in
seconds, `minutes`,
and seconds, `seconds`, respectively.

. A `SetRecurringBudgetCommand` Object with `hours+minutes+seconds` as a parameter is created and
returned to
`LogicManager`.

. `LogicManager` then calls `SetRecurringBudgetCommand#execute()`,which calls `ModelManager#setRecurrenceFrequency()`
method to update the time when the next expenses of `totalBudget` is reset.

===== Setting a Budget by Category

An extension to the budget feature, this allows the user to divide their budget based on categories. Users can
allocate parts of their budget to certain categories.
If the user's total expenses for a Category exceeds their Category Budget, a warning will be shown to the user.


. User enters command `setCategoryBudget c/School b/2.00`. The command is received by `ExpenseTrackerParser`

. `ExpenseTrackerParser` will then create a `AddCategoryBudgetCommandParser` Object and calls
`AddCategoryBudgetCommandParser#parse()` method.

. `AddCategoryBudgetCommandParser#parse()` method calls `ArgumentTokenizer#tokenize()` to tokenize the input String
into keywords and store them in an `ArgumentMultimap` Object.

. `AddCategoryBudgetCommandParser#parse()` method then calls `AddCategoryBudgetCommandParser#arePrefixesPresent()`
method. If any of the keywords are missing, `ParseException` will be thrown.

. From the previous step, if no exception is thrown, an `AddCategoryBudgetCommand` Object with `category` and `budget`
 is created and returned to `LogicManager`.

. `LogicManager` then calls `AddCategoryBudgetCommand#execute()`,which calls `ModelManager#setCategoryBudget()`
method to add a `Budget` to a `Category`.

===== Notification center (Proposed)
There is an area for the app to display notifications and additional information to the users beside the usual
area below the command box. This is particularly useful to the *Budget* feature as budgets should not obstruct the
usage of the expense tracker, but rather provide helpful information. For example, if a user exceeds his total budget
 after
 adding an expense, a warning would be displayed in the *Notification center* instead of the area below the command
 box, replacing the success message of adding an expense and confusing the user.

==== Alternatives considered
Recurrence check was initially implemented via events. Every time `ModelManager#loadUserData()` is called, an event
will be sent to the `EventBus` to be dispatched to an event handler implemented in `Budget`. However, after heavy
consideration, the recurrence check should only be called whenever `loadUserData()` is called, and never anywhere
else. Therefore, it should be more closely coupled with `loadUserData()` instead of being an event that can be posted
 from anywhere inside the application.

// end::budget[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file (default: `config.json`).

== Documentation

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu, or press kbd:[Ctrl+P] to open up the print window. A menu looking
like the figure below should show up.

.Saving documentation as PDF files in Chrome
image::chrome_save_as_pdf.png[width="300"]

.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the figure above.

[[Docs-SiteWideDocSettings]]
=== Site-wide Documentation Settings

The link:{repoURL}/build.gradle[`build.gradle`] file specifies some project-specific https://asciidoctor.org/docs/user-manual/#attributes[asciidoc attributes]
 which affects how all documentation files within this project are rendered. These attributes are described in the table below:

[cols="1,2a,1", options="header"]
.List of site-wide attributes
|===
|Attribute name |Description |Default value

|`site-name`
|The name of the website.
If set, the name will be displayed near the top of the page.
|_not set_

|`site-githuburl`
|URL to the site's repository on https://github.com[GitHub].
Setting this will add a "View on GitHub" link in the navigation bar.
|_not set_

|`site-seedu`
|Define this attribute if the project is an official SE-EDU project.
This will render the SE-EDU navigation bar at the top of the page, and add some SE-EDU-specific navigation items.
|_not set_

|===

[TIP]
Attributes left unset in the `build.gradle` file will use their *default value*, if any.

[[Docs-PerFileDocSettings]]
=== Per-file Documentation Settings

Each `.adoc` file may also specify some file-specific https://asciidoctor.org/docs/user-manual/#attributes[asciidoc attributes] which affects how the file is rendered.
Asciidoctor's https://asciidoctor.org/docs/user-manual/#builtin-attributes[built-in attributes] may be specified and used as well.
These attributes are described in the table below:

[cols="1,2a,1", options="header"]
.List of per-file attributes, excluding Asciidoctor's built-in attributes
|===
|Attribute name |Description |Default value

|`site-section`
|Site section that the document belongs to.
This will cause the associated item in the navigation bar to be highlighted.
One of: `UserGuide`, `DeveloperGuide`, ``LearningOutcomes``{asterisk}, `AboutUs`, `ContactUs`

_{asterisk} Official SE-EDU projects only_
|_not set_

|`no-site-header`
|Set this attribute to remove the site navigation bar.
|_not set_

|===

[TIP]
Attributes left unset in `.adoc` files will use their *default value*, if any.

=== Site Template

The files in link:{repoURL}/docs/stylesheets[`docs/stylesheets`] are the https://developer.mozilla.org/en-US/docs/Web/CSS[CSS stylesheets] of the site.
You can modify them to change some properties of the site's design.

The files in link:{repoURL}/docs/templates[`docs/templates`] controls the rendering of `.adoc` files into HTML5.
These template files are written in a mixture of https://www.ruby-lang.org[Ruby] and http://slim-lang.com[Slim].

[WARNING]
====
Modifying the template files in link:{repoURL}/docs/templates[`docs/templates`] requires some knowledge and experience with Ruby and Asciidoctor's API.
You should only modify them if you need greater control over the site's layout than what stylesheets can provide.
The SE-EDU team does not provide support for modified template files.
====

[[Testing]]
== Testing

=== Running Tests

There are three ways to run tests.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, carry out the following steps:
. Right-click on the `src/test/java` folder
. Click on `Run 'All Tests'` on the menu that appears

* To run a subset of tests, carry out the following steps:
. Right-click on a test package, test class, or a test
. Click on `Run 'TEST'`, where TEST is the name of the test package, class or method you are intending to test

*Method 2: Using Gradle*

* To use Gradle to run tests, carry out the following steps:
. Open a console
. If you are on windows, enter the command `gradlew clean allTests`, otherwise enter `./gradlew clean allTests` instead

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Using the https://github.com/TestFX/TestFX[TestFX] library, our GUI tests can be run in the _headless_ mode.
In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

* To run tests in headless mode, carry out the following steps:
. Open a console
. If you are on windows, enter the command `gradlew clean headless allTests`, otherwise enter `./gradlew clean headless allTests` instead

=== Types of tests

We have two main types of tests:

*  *GUI Tests* - These are tests involving the GUI. They include,
** _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
** _Unit tests_ that test the individual components. These are in `seedu.address.ui` package.
*  *Non-GUI Tests* - These are tests not involving the GUI. They include,
**  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
**  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
**  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `seedu.address.logic.LogicManagerTest`


=== Troubleshooting Testing
This section includes common issues that arise during testing.

* Problem: `HelpWindowTest` fails with a `NullPointerException`.

** Reason: One of its dependencies, `HelpWindow.html` in `src/main/resources/docs` is missing.
** Solution: Execute Gradle task `processResources`.

== Dev Ops

=== Build Automation

We use Gradle for build automation. See <<UsingGradle#, UsingGradle.adoc>> for more details.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Coverage Reporting

We use https://coveralls.io/[Coveralls] to track the code coverage of our projects. See <<UsingCoveralls#, UsingCoveralls.adoc>> for more details.

=== Documentation Previews
We use https://www.netlify.com/[Netlify] to see a preview of how the HTML version of those asciidoc files will look like when the pull request has changes to asciidoc files. See <<UsingNetlify#, UsingNetlify.adoc>> for more details.

=== Making a Release

Follow the steps below to create a new release:

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v0.1`
.  Create a new release using GitHub and upload the JAR file you created. See https://help.github.com/articles/creating-releases/
for more details.

=== Managing Dependencies

Expense Tracker depends on many third-party libraries. e.g. We use http://wiki.fasterxml.com/JacksonHome[Jackson library] for XML parsing in Expense Tracker.
Below are different ways to manage these _dependencies_:

a. Use Gradle to manage these _dependencies_. Gradle can download the dependencies automatically. (this is better than other alternatives) +
b. Include those libraries in the repo (this bloats the repo size) +
c. Require developers to download those libraries manually (this creates extra work for developers)

[appendix]
== Product Scope

*Target user profile*:

* has a need to manage a significant number of contacts
* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps

*Value proposition*: manage contacts faster than a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |new user who might forget how to use commands |be notified of the correct usage of commands that I format wrongly |correct my mistake quickly and easily.

|`* * *` |user who wants to track their expenses |add a new expense |have the app keep track of my expenses

|`* * *` |impulsive spender |set my maximum budget over a certain period of time |know when I am or about to spend
over my budget

|`* * *` |user who want to group expenditures of different categories together |add tags to an expense | find specific expenses in a later date.

|`* * *` |user who wants more information about their spending habits |search for recorded expenses by category, date or cost | reflect and learn from my past experiences.

|`* * *` |user who wants more information about their spending habits | have a visual representation of the statistical information about my spending habits | reflect and learn from my past experience.

|`* * *` |user who has trouble with overspending | have clear visual warnings or indicators when I am about to spend over my budget| better manage my spending and keep within my current budget.

|`* * *` |user |have my expenditures saved after closing the app |keep track of my expenditures without having to key in my information again

|`* * *` |clumsy typer |delete inaccurately added expenditures |have an accurate recording of my expenditures and budget

|`* * *` |clumsy typer |edit inaccurately added expenditures |have an accurate recording of my expenditures and budget

|`* * *` |user who shares their computer with others | have my own login account | keep my expenditure information separate from other users'.

|`* * *` |user |exit the application with a keyboard command | exit the application conveniently without reaching for my mouse/touchpad

|`* * *` |user who has a problem with overspending|view my expenses over a certain period of time |learn from my past endeavours and better manage my budget

|`* * *` |user who wants to save money |separate my expenses into different categories| see where am I spending more money on and where my expenses go and cut them accordingly

|`* * *` |user who is worried about privacy |remove all expenditure information from the application| comfortable knowing that my information has been completely erased.

|`* * *` |clumsy user | be able to undo or redo my commands |easily fix my mistakes.

|`* *` |user who wants their expenditure information to be private | secure my account with a password | ensure that no one can easily access my private information.

|`* *` |user who has been using the application for a long time | look at statistical information from past months | reflect and learn from my past experience.

|`* *` |user who has a monthly allowance |set my budget based on my monthly allowance | use the application with greater convienience.

|`* *` |clumsy typer |edit multiple incorrect expenditures that require the same type of edit |have an accurate recording of my expenditures and budget

|`* *` |user who spends too much in certain categories of expenses |set a budget for specific expenses | be aware of how much I am spending in a specific cate

|`* *` |advanced user |use short-form versions of commands | use the application with greater efficiency.

|`* *` |user who wants their expenditure information to be private |be able to encrypt my data | so that I can protect my private information from anyone who opens the data file.

|`* *` |user who does not know much about saving money |to be provided tips on how to save money |better manage my expenses in the future.

|`*` |user who spends on the same things frequently |add recurring expenses |do not need to key in the same type of expenditure every month

|`*` |advanced user |encrypt and decrypt strings | edit the data file directly.

|`*` |user that works in public areas |have secret categories for my expenses that only show when I want to| so that I can protect my private information.

|`*` |clumsy typer |delete multiple inaccurately added expenditures |have an accurate recording of my expenditures and budget

|`*` |user that often uses iBanking |be able to open iBanking within the application| so that I can reference my expenditure information when keying in my expenditures.

|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is the `Expense Tracker` and the *Actor* is the `user`, unless specified otherwise)

[discrete]

=== Use case: Add expenditure
*MSS*

1. User keys in command to add a given expenditure.
2. Expense Tracker adds specified expenditure.
3. ExpenseTracker displays a success message.
+
Use case ends.

*Extensions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker informs user of the error.
    ** Use case ends.

* 1b.Expense Tracker detects that the user has gone over budget.
    ** 1b1. Expense Tracker sends warning to the user.
    ** Use Case ends.

* 1c.Expense Tracker detects that the user has nearly gone budget.
    ** 1b1. Expense Tracker sends warning to the user that they have almost gone over budget.
    ** Use Case ends.

[discrete]

=== Use case: Delete expenditure

*MSS*

1. User keys in command to delete a given expenditure.
2. Expense Tracker deletes specified expenditure.
3. Expense Tracker displays a success message.
+
Use case ends

*Extensions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker informs user of the error.
    ** Use case ends.

* 1a.Expense Tracker cannot find specified expenditure.
    ** 1a1. Expense Tracker informs user that it cannot find the specified expenditure.
    ** Use case ends.

[discrete]

=== Use case: Edit expenditure

*MSS*

1. User keys in command to edit a given expenditure.
2. Expense Tracker edits the specified information of the specified expenditure.
3. Expense Tracker displays a success message.
+
Use case ends

*Extensions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker informs user of the error.
    ** Use case ends.

* 1a.Expense Tracker cannot find specified expenditure.
    ** 1a1. Expense Tracker informs user that it cannot find the specified expenditure.
    ** Use case ends.

[discrete]

=== Use case: Mass edit expenditure

*MSS*

1. User keys in command to find specific expenses from the list of all expenses.
2. Expense Tracker displays the specified expenses.
3. User keys in command to perform a mass edit on the list of expenses.
4. Expense Tracker mass edits the specified information of the specified expenditure.
+
Use case ends


*Extensions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker informs user of the error.
    ** Use case ends.

* 3a.Expense Tracker detects error in the entered data.
    ** 3a1. Expense Tracker informs user of the error.
    ** Use case ends.

* 3a.Expense Tracker cannot find specified expenditures.
    ** 3a1. Expense Tracker informs user that it cannot find the specified expenditures.
    ** Use case ends.

[discrete]

=== Use case: Set budget

*MSS*

1. User keys in command to set a budget cap.
2. Expense Tracker updates the current budget cap.
3. Expense tracker displays a success message.
+
Use case ends

*Extensions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker inform user of the error.
    ** Use case ends.

[discrete]

=== Use case: Set a recurring budget

*MSS*

1. User key in command to set a monthly recurring budget.
2. Expense Tracker sets the specified budget to reoccur after the specified time.
3. User logs into the account on a new day.
4. Expense Tracker detects that the specified period of time has passed.
5. Expense Tracker resets the budget.
+
Use case ends

*Extensions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker inform user of the error.
    ** Use case ends.

* 4a.Expense Tracker detects that the specified period of time has not passed.
    ** Use case ends.

[discrete]

=== Use case: Set a category budget

*MSS*

1. User key in command to set a budget for a specific category.
2. Expense Tracker sets the specified budget to the specified category.
3. Expense Tracker displays success message.
+
Use case ends

*Extensions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker inform user of the error.
    ** Use case ends.

[discrete]

=== Use case: Signup for an account

*MSS*

1. User keys in command to signup for an account.
2. Expense Tracker creates a new account with the specified username.
+
Use case ends

*Exceptions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker informs user of the error.
    ** Use case ends.

* 1a.Expense Tracker that an account of that username already exists.
    ** 1a1. Expense Tracker informs user that the username has been taken.
    ** Use case ends.

[discrete]

=== Use case: Login without password

*MSS*

1. User keys in command to login to an account.
2. Expense Tracker logs user into account.
+
Use case ends

*Exceptions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker informs user of the error.
    ** Use case ends.

* 1a.Expense Tracker detects that specified user does not exist.
    ** 1a1. Expense Tracker informs user that user does not exist
    ** Use case ends.

* 1a. Expense Tracker detects that the account is password-protected.
** 1a1. Expense tracker informs the user that a password is required.
** Use case ends

[discrete]

=== Use case: Login without password

*MSS*

1. User keys in command to login to an account.
2. Expense Tracker logs user into account.
+
Use case ends

*Exceptions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker informs user of the error.
    ** Use case ends.

* 1a.Expense Tracker detects that specified user does not exist.
    ** 1a1. Expense Tracker informs user that user does not exist
    ** Use case ends.

* 1a. Expense Tracker detects that the account is password-protected.
** 1a1. Expense tracker informs the user that a password is required.
** Use case ends

[discrete]

=== Use case: Login with password

*MSS*

1. User keys in command to login to an account.
2. User also enters password of account.
2. Expense Tracker logs user into account.
+
Use case ends

*Extensions*

* 2a.Expense Tracker detects error in the entered data.
    ** 2a1. Expense Tracker informs user of the error.
    ** Use case ends.

* 2a.Expense Tracker detects that specified user does not exist.
    ** 2a1. Expense Tracker informs user that user does not exist
    ** Use case ends.

* 2a. Expense Tracker detects that the password is incorrect.
** 2a1. Expense tracker informs the user that the entered password is incorrect.
** Use case ends

[discrete]

=== Use case: Set password

*MSS*

1. User keys in command to set a password.
2. Expense Tracker sets the password for the account that is currently logged into to the specified password
3. Expense Tracker displays a success message

*Extensions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker informs user of the error.
    ** Use case ends.


* 1a.Expense Tracker detects that the user is not logged in.
    ** 1a1. Expense Tracker informs user that they need to log into an account.
    ** Use case ends.

[discrete]

=== Use case: Clear

*MSS*

1. User keys in command to clear information from an account.
2. Expense tracker deletes all information about the current user’s expenses.
3. Expense Tracker displays a success message.
+
Use case ends

[discrete]

=== Use Case: Find Expenses
*MSS*

1. User keys in command to find specific expenses from the list of all expenses.
2. Expense Tracker displays the specified expenses.
3. Expense Tracker displays a success message.
+
Use case ends

*Extensions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker informs user of the error.
    ** Use case ends.

[discrete]

=== Use case: Toggle Notification

*MSS*

1. User keys in command to toggle on or off automated notifications.
2. Expense Tracker toggles automated notifications to the specified status.
3. Expense Tracker displays a success message.
+
Use case ends

*Extensions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker informs user of the error.
    ** Use case ends.

[discrete]

=== Use case: View statistics

*MSS*

1. User keys in command to view the statistics of his expenditure information from a specified period of time.
2. Expense Tracker displays the statistics of the specified information.
3. Expense Tracker displays success message.
+
Use case ends

*Extensions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker informs user of the error.
    ** Use case ends.

[discrete]

=== Use case: Open Help Window
*MSS*

1. User keys in command to open Help Window.
2. Expense Tracker opens a Help Window.
3. Expense Tracker displays success message.
+
Use case ends

*Extensions*

* 1a.Expense Tracker detects that a Help window has already been open.
    ** Use case resumes from step 3.

[discrete]

=== Use case: Redo Command
*MSS*

1. User keys in command to redo an undone command.
2. Expense Tracker redoes the undone command.
3. Expense Tracker displays success message.
+
Use case ends

*Extensions*

* 1a.Expense Tracker detects that are no commands to redo.
    ** 1a1. Expense Tracker informs user that are no commands to redo.
    ** Use case ends.

[discrete]

=== Use case: Undo Command
*MSS*

1. User keys in command to undo a previous command.
2. Expense Tracker undoes previous command.
+
Use case ends

*Extensions*

* 1a.Expense Tracker detects that are no commands to undo.
    ** 1a1. Expense Tracker informs user that are no commands to undo.
    ** Use case ends.

[discrete]

=== Use case: List
*MSS*

1. User keys in command to list expenses.
2. Expense Tracker displays the list of all recorded expenses.
+
Use case ends

*Extensions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker informs user of the error.
    ** Use case ends.

[discrete]

=== Use case: Encrypt
*MSS*

1. User keys in command to encrypt a specified string.
2. Expense Tracker encrypts the specified string with the user's encryption key.
+
Use case ends

*Extensions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker informs user of the error.
    ** Use case ends.

[discrete]

=== Use case: Decrypt
*MSS*

1. User keys in command to decrypt a specified encrypted string.
2. Expense Tracker decrypts the specified string with the user's encryption key.
+
Use case ends

*Extensions*

* 1a.Expense Tracker detects error in the entered data.
    ** 1a1. Expense Tracker informs user of the error.
    ** Use case ends.

* 1a.Expense Tracker detects that the specified string was not encrypted with the user's encryption key.
    ** 1a1. Expense Tracker informs user that the specified string was not encrypted with the user's encryption key.
    ** Use case ends.

[discrete]

=== Use case: Exit Expense Tracker
*MSS*

1. User keys in command to exit out of Expense Tracker.
2. Expense Tracker shuts down.
+
Use case ends

[discrete]

[appendix]

== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `9` or higher installed.
.  Should be able to hold up to 1000 expenses without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.

_{More to be added}_

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[private-contact-detail]] Private contact detail::
A contact detail that is not meant to be shared with others

//[appendix]
//== Product Survey
//
//*Product Name*
//
//Author: ...
//
//Pros:
//
//* ...
//* ...
//
//Cons:
//
//* ...
//* ...

//[appendix]
//== Instructions for Manual Testing
//
//Given below are instructions to test the app manually.
//
//[NOTE]
//These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a expense

. Deleting a expense while all expenses are listed

.. Prerequisites: List all expenses using the `list` command. Multiple expenses in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No expense is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_
